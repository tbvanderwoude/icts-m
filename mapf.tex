\documentclass[a4paper,10pt,english]{article}
\usepackage[T1]{fontenc}
\usepackage{marginnote}
\usepackage{geometry}
\geometry{verbose,tmargin=3cm,bmargin=3cm,lmargin=3cm,rmargin=3cm}
\usepackage[backend=bibtex]{biblatex}
\addbibresource{sources.bib}
\usepackage{babel}


\title{Reviewed: Multi-Agent Pathfinding: Definitions, Variants, and Benchmarks}
\author{Thom van der Woude}
\date{\today}

\begin{document}
	\maketitle
	\paragraph{First run-through}
	This paper is about unifying terminology and methodology (by providing common benchmarks and evaluation methods) of MAPF research to find a common language to express results in. First classical MAPF is formally described, different types of conflicts are discussed and also what agents do when they reach the target (Disappear or either stay put or move out of the way if this is needed). Makespan and sum of cost are mentioned as the two typical objective functions.
	
	Then variants past classical MAPF are discussed: first, MAPF on weighted graphs; second, additional feasibility rules that assert robustness of solutions to short delays or more complex rules that restrict possible actions of agents by requiring them to maintain 'formation', keep a communication link up or something similar (quite relevant in real-world settings).
	
	MAPF is quite abstract: many practical applications need MAPF plans to be translated to motion plannings for physical agents with more properties to consider.
	
	There are also anonymous, colored and online MAPF. Online MAPF has two variants: a warehouse model where agents are retasked after reaching target and a road intersection model where agents with set targets may appear.
	
	Benchmarks: there are the Dragon Age Origins maps, open nxn grids, nxn grids with some random obstacles nad warehouse grids. Source and target assignment is done randomly, using clustered sources and targets (more difficult instances) or picking from pools of designated sources and targets.
	
	Two real benchmarks: Grid-based MAPF (introduced in this paper!) using movingAI maps like DAO.
	Asprilo for simulating an automated warehouse.
	\section{Summary}
	MAPF: planning paths for multiple agents without them colliding as they concurrently move towards their goals. Applications range from automated warehouses and automotives to robotics and videogames. This paper will both present a unified terminology, go over the classical MAPF and classify different types of extensions and variations and introduce a new grid-based benchmark for emperical comparison of algorithms based on the movingAI maps. "This paper aims to address this growing challenge by introducing a unified terminology to describe MAPF problems, and by establishing common benchmarks and evaluation measures for evaluating MAPF algorithms." References to state-of-the-art surveys: \cite{Felner2017,ma2016}
	\paragraph{A statement of classical MAPF}
	The MAPF problem input assuming $k$ agents is $\langle G, s, t\rangle$ with an undirected graph $G = (V,E)$ and $s,t$ such that $s: [1,\ldots,k] \to V$ maps agents to source vertices, $t: [1,\ldots,k] \to V$ maps agents to target vertices. Time is discretized and agent speed is uniform: at each step, each agent can perform a single action $a : V \to V$ (actions are functions from vertices to vertices) so $a(v) = v'$ will be the vertex in the next time-step if $a$ is chosen. By assuming each $v\in V$ to have a self-loop, for any $a(v) = v'$, $(v,v') \in E$. If $v' = v$, this corresponds to waiting for a single step.
	
	Given agent $i$ and sequence of actions (path) $\pi = (a_1,\ldots,a_n)$, let $\pi_i[x]$ denote the location of $i$ after executing the first $x$ actions in $\pi$ so that $\pi_i[x] = a_x(a_{x-1}(\cdots(a_1(s(i)))\cdots))$. If $\pi_i[|\pi|] = t(i)$, $\pi$ is a single-agent plan. $k$ single-agent plans for different agents define a solution to the MAPF problem.
	
	\paragraph{Conflicts and at-target behaviour}
	Conflicts relevant to the project are
	\begin{enumerate}
		\item Vertex conflict: $\pi_i,\pi_j$ conflict if for some time-step $x$, $\pi_i[x] = \pi_j[x]$.
		\item Edge conflict: $\pi_i,\pi_j$ conflict if for some time-step $x$, $\pi_i[x] = \pi_j[x]$ and $\pi_i[x+1] = \pi_j[x+1]$
		\item Swapping conflict: $\pi_i,\pi_j$ conflict if for some time-step $x$, $\pi_i[x] = \pi_j[x+1]$ and $\pi_i[x+1] = \pi_j[x]$
	\end{enumerate}
	Following and cycling conflicts are also described but are not so relevant.
	
	Upon reaching target, an agent $i$ can either stay there so that for $t\geq |\pi_i|$, $\pi_i[t] = \pi_i[|\pi_i|]$ (with all the usual (vertex) conflicts) or disappear 'into' the target, meaning that it will never conflict with another agent $j$.
	\paragraph{Objective functions}
	Given solution $\pi = \{\pi_1,\cdots,\pi_k\}$ , there are two common objective functions:
	\begin{itemize}
	\item Makespan, or the total number of steps for all agents to reach their target, defined as $\max_{1\leq i \leq k} |\pi_i]$
	\item Sum of costs, defined as $\sum_{1\leq i \leq k} |\pi_i|$ (sometimes called flowtime)
	\end{itemize}
	\marginnote{The paper refers to search-based and compilation-based methods}
	\paragraph{Past classical MAPF}
	MAPF on weighted graphs models variable action-times. Weighted graphs have been studied are $2^k$-neighbour grids and graphs representing points in euclidean space (as in roadmaps).
	
	There are also alternative feasibility rules, besides the basic no-conflicts rule: you could want a k-robust MAPF plan where each agent can be delayed $0-k$ timesteps without there being any conflicts. Similarly, you might impose rules that restrict agent actions to make sure they keep formation, and let maintaining formation be an additional feasibility rule. 
	
	Another line of variations involve bridging the gap between the abstract MAPF and concrete motion planning problem that has to program actual agents with limited degrees of freedom to move through a space. This requires considering the 'configuration' an agent is in: the location, orientation, velocity and so on. Depending on what aspect of the physical agent is important, you could either focus on the volume they occupy by perhaps marking more surrounding vertices as occupied, or consider kinematic constraints in action selection, resulting in a directed graph.
	\paragraph{Anonymous, colored and online MAPF}
	Lastly, you can consider the relation between tasks and agents. In classical MAPF, each agent has a single target. Alternatively, you could do anonymous MAPF where exactly one agent needs to get to each target but it doesn't matter which agent goes to which target. Generalizing this idea, you could divide agents into groups (color the agents), similarly group targets and plan so that agents within groups are matched to targets that belong to that group. In online MAPF, agents still at any point in time have a single target, but you want to solve MAPF-like problems in sequence on the same graph. There are two main online models: in a warehouse model, you reassign agents that have got to their target; in a road intersection model, you have new agents appear with each one task.  
	\section{Benchmarks}
	To evaluate MAPF algorithms, you can consider different types of graphs:
	\begin{enumerate}
		\item Open NxN grids
		\item Unstructuerd NxN grids with random obstacles
		\item Structured maps like Dragon Age Origins maps
		\item Warehouse grids or grids modelling other relevant real-world applications
	\end{enumerate}
	You also need to assign sources and targets systematically:
		\begin{enumerate}
			\item Random. You generate random vertex pairs with paths between them
			\item Clustured. You can generate one random pair and cluster source and target around this pair for a more complex problem (more conflicts probably)
			\item Designated. You can handcraft source and target vertices, perhaps to model something like warehouse protocols.
	\end{enumerate}
	\paragraph{Grid-based MAPF benchmark and Asprilo}
	Uses a wide variety of graphs from the MovingAI pathfinding repository. Each map has 25 scenarios with source and target vertex lists. As a robust benchmark method, you could set a time-out of say 30 seconds assuming a set hardware-software setup. Then try to solve each scenario (different s,t lists) with as many agents as possible in increasing order until a time-out occurs, and consider the resulting statistic (worst and best scenario, agents in average scenario and so on). Modulo hardwarde-software implementation considerations, this gives a robust emperic way of comparing algorithms.
	
	Asprilo has a M domain which corresponds to MAPF in an automated warehouse setting.
	
	\paragraph{Conclusion}
	The authors hope that this unification of MAPF terminology and emperical evaluation will be useful to the MAPF community.
	\printbibliography
	
\end{document}
